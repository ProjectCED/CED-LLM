from flask import jsonify, Blueprint, request
from flask_cors import CORS
from app.api_handler import ApiHandler
from app.database import Database, NodeProperties, NodeLabels
from dotenv import load_dotenv
import os
from app.models.blueprint import Blueprint as BP
from app.models.project import Project
from app.models.result import Result
from neo4j.time import DateTime

"""
This file contains the backend API for the application. It handles the file management, analysis, and database handling.
"""

main = Blueprint('main', __name__)
apiHandler = ApiHandler()
database = Database()

frontend_port = os.getenv('VITE_PORT', '5173')
CORS(main, resources={r"/*": {"origins": "http://localhost:{frontend_port}"}})  # Allows connections between domains

# File management & analysis
@main.route('/upload_file', methods=['POST'])
def upload_file():
    """
    Uploads a file to the server and returns the filename.
    Should be used before analyzing the file.

    Parameters:
        Method: POST
        file: File to be uploaded, under the name 'file'. Use FormData to upload.

    Returns:
        string: Filename of the uploaded file.
    """
    file = request.files.get('file')
    filename = file.filename
    file.save(filename)

    return filename

# For analyzing files using OpenAI
@main.route('/analyze_file', methods=['POST'])
def analyze_file():
    """
    Analyzes the already uploaded file using the specified blueprint.
    Deletes the file after analysis, as it is no longer needed.
    Upload file before analyzing.

    Parameters:
        Method: POST
        filename: Filename of the uploaded file. Can be gotten from '/upload_file' endpoint.
        blueprint: Blueprint dict, needed for questions for the LLM.
            Can be null if analyzing with 'default/automatic blueprint'.
    
    Returns:
        string: Analysis results generated by the LLM. Can be null if backend runs into issues
            such as rate limits.
    """
    filename = request.json['filename']
    blueprint = request.json['blueprint']
    model = request.json['model']
    results = apiHandler.analyze_file(filename, blueprint, model)

    # TODO: Actually handle errors. Currently not stability-threatening, but should be implemented.
    try:
        os.remove(filename)
    except FileNotFoundError:
        pass
    except PermissionError:
        pass
    
    return jsonify(results)

@main.route('/analyze_text', methods=['POST'])
def analyze_text():
    """
    Analyzes the given text using the specified blueprint. Used as an alternative to '/analyze_file'.

    Parameters:
        Method: POST
        text: Text to be analyzed.
        blueprint: Blueprint dict, needed for questions for the LLM.
            Can be null if analyzing with 'default/automatic blueprint'.

    Returns:
        string: Analysis results generated by the LLM. Can be null if backend runs into issues
            such as rate limits.
    """
    text = request.json['text']
    blueprint = request.json['blueprint']
    model = request.json['model']
    results = apiHandler.analyze(text, blueprint, model)

    return jsonify(results)

# Database handling
# Blueprints

def __get_whole_blueprint(id: str) -> dict:
    """
    Gets the whole blueprint with all properties for given ID.

    Args:
        id (string): UUID-type ID of the blueprint node in the database.

    Returns:
        dict: Blueprint with all properties.
    """
    name = database.lookup_node_property(id, NodeLabels.BLUEPRINT, NodeProperties.Blueprint.NAME)
    description = database.lookup_node_property(id, NodeLabels.BLUEPRINT, NodeProperties.Blueprint.DESCRIPTION)
    questions = database.lookup_node_property(id, NodeLabels.BLUEPRINT, NodeProperties.Blueprint.QUESTIONS)
    return {"id": id, "name": name, "description": description, "questions": questions}

def __get_whole_used_blueprint(id: str) -> dict:
    """
    Gets the whole used blueprint with all properties for given ID.

    Args:
        id (string): UUID-type ID of the used blueprint node in the database.

    Returns:
        dict: used Blueprint with all properties.
    """
    name = database.lookup_node_property(id, NodeLabels.USED_BLUEPRINT, NodeProperties.Blueprint.NAME)
    description = database.lookup_node_property(id, NodeLabels.USED_BLUEPRINT, NodeProperties.Blueprint.DESCRIPTION)
    questions = database.lookup_node_property(id, NodeLabels.USED_BLUEPRINT, NodeProperties.Blueprint.QUESTIONS)
    return {"id": id, "name": name, "description": description, "questions": questions}


@main.route('/get_blueprints', methods=['GET'])
def get_blueprints():
    """
    Gets all blueprints from the database.

    Parameters:
        Method: GET

    Returns:
        list[dict]: List of blueprints with all properties.
    """
    blueprints = database.lookup_nodes(NodeLabels.BLUEPRINT) # [[ID, NAME]]
    blueprints_with_all_properties = []
    for bp in blueprints:
        id = bp[0]
        blueprint = __get_whole_blueprint(id)
        blueprints_with_all_properties.append(blueprint)
    return jsonify(blueprints_with_all_properties)


@main.route('/save_blueprint', methods=['POST'])
def save_blueprint():
    """
    Saves a blueprint to the database. Also used for updating blueprints.
    To update an existing blueprint, provide the ID under 'id'.

    Parameters:
        Method: POST
        name: User-given name of the blueprint.
        description: User-given description of the blueprint.
        id: UUID-type ID of the blueprint node in the database. If updating, provide the ID.
        question: Main question for the blueprint.
        addedQuestions: Additional questions for the blueprint.

    Returns:
        string: UUID-type ID of the newly created/updated blueprint node in the database.
    """
    data = request.json
    name = data['name']
    description = data['description']
    id = data['id']

    # On the frontend, questions are divided in the "main" question and additional questions
    question = data['question']
    addedQuestions = data['addedQuestions']

    # Merge questions to one list
    questions = [question] + addedQuestions

    bp = BP(name, description, questions, id)

    # Returns the ID
    return bp.save_blueprint()

@main.route('/delete_blueprint', methods=['POST'])
def delete_blueprint():
    """
    Deletes a blueprint from the database.

    Parameters:
        Method: POST
        id: UUID-type ID of the blueprint node in the database.

    Returns:
        dict: Success (true/false) of the deletion under key 'success'.
    """
    id = request.json['id']

    # True/false
    success = database.delete_node(id, NodeLabels.BLUEPRINT)
    return jsonify({"success": success})


@main.route("/mistral", methods=["POST"])
def query_mistral():
    data = request.json
    prompt = data.get("prompt", "Explain the theory of relativity in layman's terms.")
    response = apiHandler.mistral_analyze(prompt)
    return jsonify(response)

# Projects
@main.route('/save_project', methods=['POST'])
def save_project():
    """
    Saves a project to the database. All project are initially empty, so only the name is needed.
    Adding results under a project is done via '/save_result'.

    Parameters:
        Method: POST
        projectName: User-given name of the project.

    Returns:
        string: UUID-type ID of the newly created project node in the database.
    """
    name = request.json['projectName']
    project = Project(name)
    return project.save_project()

@main.route('/get_projects', methods=['GET'])
def get_projects():
    """
    Gets all projects and results under them from the database as a list.
    Each project has a list of results, which have a blueprint dict attached.

    Parameters:
        Method: GET

    Returns:
        list[dict]: List of projects with all properties, results and their blueprints.
    """
    projects = database.lookup_nodes(NodeLabels.PROJECT) # [[ID, NAME, DATETIME]]
    projects_with_all_properties = []
    for proj in projects:
        id = proj[0]
        name = proj[1]
        results = __get_results_for_project(id)
        projects_with_all_properties.append({"id": id, "open": False, "name": name, "results": results})
    return jsonify(projects_with_all_properties)

@main.route('/delete_project', methods=['POST'])
def delete_project():
    """
    Deletes a project from the database.

    Parameters:
        Method: POST
        id: UUID-type ID of the project node in the database.

    Returns:
        dict: Success (true/false) of the deletion under key 'success'.
    """
    id = request.json['id']

    # True/false
    success = database.delete_node(id, NodeLabels.PROJECT)
    return jsonify({"success": success})

# Results

def __get_results_for_project(projectId):
    """
    Gets all results for a project with all properties. Also gets the blueprint for each result using `__get_whole_blueprint()`

    Args:
        projectId (string): UUID-type ID of the project node in the database.

    Returns:
        list[dict]: List of results with all properties (and blueprints).
    """
    results = database.lookup_nodes(NodeLabels.RESULT_BLUEPRINT, NodeLabels.PROJECT, projectId)
    results_with_all_properties = []
    for res in results:
        id = res[0]
        name = database.lookup_node_property(id, NodeLabels.RESULT_BLUEPRINT, NodeProperties.ResultBlueprint.NAME)
        filename = database.lookup_node_property(id, NodeLabels.RESULT_BLUEPRINT, NodeProperties.ResultBlueprint.FILENAME)
        result = database.lookup_node_property(id, NodeLabels.RESULT_BLUEPRINT, NodeProperties.ResultBlueprint.RESULT)

        # TODO: Workaround for Automatic-blueprint problem (isn't saved in database)
        temp = database.lookup_nodes(NodeLabels.USED_BLUEPRINT, NodeLabels.RESULT_BLUEPRINT, id)
        used_blueprint_id = None
        if temp != []:
            used_blueprint_id = temp[0][0]

        used_blueprint_info = __get_whole_used_blueprint(used_blueprint_id)
        results_with_all_properties.append({"id": id, "name": name, "filename": filename, "result": result, "blueprint": used_blueprint_info})
    return results_with_all_properties

@main.route('/save_result', methods=['POST'])
def save_result():
    """
    Saves a result to the database. The result is connected to a project.

    Parameters:
        Method: POST
        name: User-given name of the result.
        filename: Name of the analyzed file, if one was used. Can be null if the result was generated from text.
        blueprint: Blueprint dict used to create the result.
        result: The analysis result text generated by the LLM.
        projectId: UUID-type ID of the project under which the result was created.

    Returns:
        string: UUID-type ID of the newly created result node in the database.
    """
    data = request.json
    name = data['name']
    filename = data['filename']

    blueprint = data['blueprint']
    blueprint_id = blueprint.get('id') if blueprint else None
    
    result = data['result']
    projectId = data['projectId']

    #refresh datetime
    database.set_node_property(projectId, NodeLabels.PROJECT, NodeProperties.Project.DATETIME, DateTime.now())

    res = Result(name, filename, blueprint_id, result, projectId)
    return res.save_result()

@main.route('/delete_result', methods=['POST'])
def delete_result():
    """
    Deletes a result from the database.

    Parameters:
        Method: POST
        id: UUID-type ID of the result node in the database.

    Returns:
        dict: Success (true/false) of the deletion under key 'success'.
    """
    id = request.json['id']

    # True/false
    success = database.delete_node(id, NodeLabels.RESULT_BLUEPRINT)
    return jsonify({"success": success})

if __name__ == '__main__':
    main.run(debug=True)
